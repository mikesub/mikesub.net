---
title: Welcome to the fall
date: 2024-09-10 15:00
photo: https://media.githubusercontent.com/media/mikesub/mikesub.net/master/photos/objects.jpg
---

![](https://media.githubusercontent.com/media/mikesub/mikesub.net/master/photos/objects.jpg)

One thing that surprised me when I moved to the Netherlands was the difference in how the seasons are observed.
It turns out that there are at least two ways: astronomical and calendar-based. I was used to calendar seasons, where
each season has three months, starting on the first and ending on the last day of the respective months. While some countries use astronomical approach where it's defined by solstices and equinoxes.
So, for me, it's already autumn, while for you, it might still be summer. Lucky you.

The first correspondence has arrived! I didn't expect to get any response to my invitation for letters exchange but it worked. All this blogging is not in vain. Phew. (and EPS FTW!) Actually, at some point in the past, I wondered if anybody was reading these notes. I don't have any analytics, and I host it via GitHub Pages so I don't even have access logs or anything. But it seems like someone is out there. Nice. Speaking of access logs, I stumbled upon Caddy, a webserver in Go. It might be slower than nginx, but at least its configs don't make eyes bleed. That's worth something, as we all've just developed a bit of Stockholm syndrome.

Caddy was mentioned in a episode of Software Unscripted, where they touched upon why functional languages are less popular than imperative ones. There are many valid reasons, but one interesting observation was that functional languages make easy things a bit harder, while making hard things easier. And most people don't care about the hard stuff. I totally agree that they make hard things made easier, but I'm not so sure about easy things becoming harder. Are while/for loops really easier to write than a recursion? Who wouldn't like more uniform, predictable and easier syntax? Who would, in the right mind, avoid immutability? To me, it all just feels like not much more than a mix of bad luck, timing, marketing. And people are known for using inferior tools and that's totally fine. Look at Tailwind CSS.

Speaking of which and the broader frontend, I got immersed in it at the beginning, didn't know anything outside and thought everything was fine as it could and should be. Then I learned about other approaches, saw how things are handled in other languages and understood the point that frontend is quite a mess. Then I stepped away from coding, gained some distanced and my opinion transformed into more humble one — of course, there are issues but nothing critical, it's just a matter of taste and preference, really. Recently, though, I got my hands back on coding and took a shower of multi-gigabytes of node_modules, complexities of compilation tools, a zoo of bundlers, multiple standards of, hey, importing modules. DHH, talking about this year being the year of Linux on the desktop, mentioned that "if you're able to figure out how to setup a modern build pipeline for JavaScript or even correctly configure IAM for AWS, you already have all the stamina you need for the Linux journey. Think about giving it another try. Not because it is easy, but because it is worth it". So, what is figuring out a modern JS build pipeline really worth for?

Links:
- [TypeScript support in Node.js](https://github.com/nodejs/loaders/issues/217)
- [InstantDB](https://www.instantdb.com/)
- [Caddy](https://caddyserver.com/)
- [Software Unscripted podcast](https://pod.link/1602572955)
- [DHH](https://world.hey.com/dhh/)

Music:
- [Nick Cave & The Bad Seeds — Wild God](https://nickcave-badseeds.ffm.to/wild-god)
